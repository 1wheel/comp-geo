<!DOCTYPE html>
<meta charset="utf-8">

<style>
body{
  max-width: 900px;
  margin: 0px auto;
  font-family: monospace;
  background: black;
}

.point{
  stroke: #fff;
  fill: #fff;
  cursor: pointer;
}

.line{
  stroke: #fff;
}

.intersection{
}

svg{
  /*border: 1px solid #ccc;*/
  overflow: visible;
}
</style>


<body>
  <div id='graph'></div>
</body>

<script src="../libs/d3v4+jetpack.js"></script>
<script src="../libs/heap.js"></script>
<script src="../libs/lodash.js"></script>
<script src="../libs/buckets.js"></script>

<script src='../geometry.js'></script>


<script>

var width = 960, height = 500, ε = 1e-9, ƒ = d3.f, r = 10;

var drag = d3.drag().on('drag', function(d){
  d[0] = Math.round(clamp(r, d3.event.x, width - r))
  d[1] = Math.round(clamp(r, d3.event.y, height - r))
  render()
})


var svg = d3.select('#graph').append('svg')
    .at({width, height})

//copy(JSON.stringify(lines, null, 0))
var lines = [[[704,183],[108,110]],[[163,303],[553,381]],[[354,439],[542,69]],[[224,206],[446,38]]]

var lineSel = svg.appendMany(lines, 'path.line')
    
var circleSel = svg.appendMany(_.flatten(lines, true), 'circle.point')
    .at({r})
    .call(drag)

var intersectionSel = svg.append('circle.intersection')
    .at({fill: 'none', r: r/2, 'stroke-width': 2})

function render(){
  lineSel.at('d', pathStr)
  circleSel.translate(ƒ())

  var i = intersection(lines[0], lines[1])
  intersectionSel
      .translate(i)
      .at({stroke: i.isIntersection ? '#0f0' : '#ccc'})

  var intersections = allIntersections(lines)
  d3.selectAll('.intersection').remove()

  svg.appendMany(intersections, 'circle.intersection')
      .at({fill: 'none', r: r/2, 'stroke-width': 2, stroke: '#0f0'})
      .translate(ƒ())

  console.log(intersections)
}
render()

function allIntersections(lines){
  function ySlant(d){ return d.p[1] + ε*d.p[0] }
  var eventQueue = tree(ySlant)
  lines.forEach(function(d){
    var isSorted = d[0][1] - d[1][1] || d[0][0] - d[1][0]
    var p0 = isSorted < 0 ? d[0] : d[1]
    var p1 = isSorted < 0 ? d[1] : d[0]

    eventQueue.insert({
      p: p0,
      type: 'insert',
      line: d
    })

    eventQueue.insert({
      p: p1,
      type: 'remove',
      line: d
    })
  })

  var curEvent;
  var intersections = []
  var segmentOrder = tree(function(d){ return lineXatY(d, curEvent.p[1]) })


  for (; curEvent = eventQueue.popSmallest(); curEvent){
    if (curEvent.type == 'insert'){
      segmentOrder.insert(curEvent.line)

      segmentOrder.neighbors(curEvent.line).forEach(function(d){
        checkForIntersection(curEvent.line, d)
      }) 
    }

    if (curEvent.type == 'remove'){
      checkForIntersection.apply(null, segmentOrder.neighbors(curEvent.line))

      segmentOrder.remove(curEvent.line)
    }

    if (curEvent.type == 'intersect'){
      segmentOrder.swap(curEvent.p.lines[0], curEvent.p.lines[1])

      segmentOrder.neighbors(curEvent.p.lines[0]).forEach(function(d){
        if (d == curEvent.p.lines[1]) return
        checkForIntersection(curEvent.p.lines[0], d)
      }) 
      segmentOrder.neighbors(curEvent.p.lines[1]).forEach(function(d){
        if (d == curEvent.p.lines[0]) return
        checkForIntersection(curEvent.p.lines[1], d)
      }) 

    }
  // console.log(segmentOrder.length)
  }

  function checkForIntersection(a, b){
    if (!a || !b) return

    var i = intersection(a, b)
    if (!i.isIntersection) return
    i.lines = [a, b]

    eventQueue.insert({
      p: i,
      type: 'intersect',
    })

    intersections.push(i)
  }

  return intersections

}

</script>